% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Parallel_PELTSM1.R
\name{Parallel_PELTSM1}
\alias{Parallel_PELTSM1}
\title{Parallel PELT SM1}
\usage{
Parallel_PELTSM1(data, penalty, pruning, sum.stat = norm.sum,
  cost = norm.mean.cost, ncores = 2, boundary = "fixed",
  boundary_value = 0, minseglen)
}
\arguments{
\item{data}{A vector of data-points within which you with to find changepoints.}

\item{penalty}{The value of the penalty.}

\item{pruning}{If true PELT is used, if false Optimal Partitioning is used.}

\item{sum.stat}{This can be ``norm.sum" or ``exp.sum".}

\item{cost}{This can be ``norm.mean.cost", ``norm.var.cost", ``norm.meanvar.cost" or ``exp.cost".}

\item{ncores}{Number of cores to use.}

\item{boundary}{This can either be ``fixed" or ``adaptive".}

\item{boundary_value}{If boundary is fixed then this is the number of points to use around the boundary.}

\item{minseglen}{Minimim length a segment can be}
}
\value{
The detected changepoints.
}
\description{
Splits the data into chunks and runs parallel changepoint detection on each chunk then merges the results and runs parallel detection using the detected changepoints in step 1 as the candidate changepoint locations.
}
\examples{

### Set up parallel environment ###
library(doParallel)
library(foreach)

ncores <- c(10)
cl <- makeCluster(ncores)
registerDoParallel(cl)
### Generate some data from the blocks data set ####
cpts <- round(c(0,0.1, 0.13, 0.15, 0.23, 0.25, 0.40, 0.44, 0.65, 0.76, 0.78, 0.81,1)*10000)
segment_param <- c(0, 4, -1, 2, -2, 3, -1.2, 0.9, 5.2, 2.1, 4.2, 0)
data <- NULL

for (i in 1:(length(cpts)-1)){
  data_new <- rep(segment_param[i],cpts[i+1] - cpts[i])
 data <- c(data, data_new)
}
data <- data + rnorm(10000,0,1)

Parallel_PELTSM1(data, 2*log(length(data)), TRUE, sum.stat = norm.sum, cost = norm.mean.cost, ncores=10, boundary = "fixed",boundary_value = 20, 1)
}
\author{
Kaylea Haynes
}

